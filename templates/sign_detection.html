<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sign Language Translator</title>
    <!-- Add these in the head section of your HTML -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #6366f1;
            --secondary-color: #4338ca;
            --background-color: #f5f3ff;
            --text-color: #1f2937;
            --card-background: white;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            padding: 40px 0;
        }

        .header h1 {
            font-size: 3rem;
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        .header p {
            color: var(--text-color);
            font-size: 1.1rem;
            max-width: 600px;
            margin: 0 auto;
        }

        .video-section {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            margin-top: 30px;
        }

        .video-container {
            position: relative;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 15px 30px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .video-container:hover {
            transform: scale(1.02);
        }

        #video {
            width: 640px;
            height: 480px;
            background-color: #000;
            object-fit: cover;
        }

        .results-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            background-color: var(--card-background);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.05);
            min-width: 300px;
        }

        .result-card {
            background-color: var(--background-color);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .result-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .result-label {
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        .result-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--secondary-color);
        }

        .back-button {
            display: inline-block;
            margin-top: 20px;
            padding: 12px 24px;
            background-color: var(--primary-color);
            color: white;
            text-decoration: none;
            border-radius: 10px;
            transition: background-color 0.3s ease;
        }

        .back-button:hover {
            background-color: var(--secondary-color);
        }

        .footer {
            text-align: center;
            padding: 20px;
            background-color: var(--card-background);
            margin-top: 30px;
            color: var(--text-color);
        }

        @media (max-width: 1024px) {
            .video-section {
                flex-direction: column;
            }

            #video {
                max-width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>Sign Language Translator</h1>
            <p>Real-time sign language detection and translation powered by advanced computer vision technology</p>
        </header>

        <section class="video-section">
            <div class="video-container">
                <video id="video" autoplay></video>
            </div>

            <div class="results-container">
                <div class="result-card">
                    <div class="result-label">Detected Gesture</div>
                    <div id="gestureLabel" class="result-value">DETECTING...</div>
                </div>
                <div class="result-card">
                    <div class="result-label">Meaning</div>
                    <div id="sentenceLabel" class="result-value">Waiting for sign...</div>
                </div>
            </div>
        </section>

        <a href="#" onclick="window.history.back()" class="back-button">Go Back</a>
    </div>

    <footer class="footer">
        <p>Â© 2025 Disability Assistant - Bridging Communication Gaps</p>
    </footer>

    <script>
       // Sign Language Detection Script

// Global variables for video and processing
// Global variables
// Global variables
let video;
let handPoseModel;
let predictions = [];
let isProcessing = false;
let lastProcessedTime = 0;
let processingInterval = 100; // Process frames every 100ms
let gestureHistory = []; // Store recent gestures for stability
let historyMaxLength = 5; // Number of frames to consider for stability

// Initialize the application
document.addEventListener('DOMContentLoaded', async () => {
    // Initialize video element
    video = document.getElementById('video');
    
    try {
        // Setup camera
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { 
                width: { ideal: 640 },
                height: { ideal: 480 },
                facingMode: 'user' 
            }
        });
        
        video.srcObject = stream;
        video.play();
        
        // Load handpose model from TensorFlow.js
        await loadHandposeModel();
        
        // Start detection loop
        startDetection();
    } catch (error) {
        console.error("Initialization error:", error);
        updateUIWithError('Setup Error', 'Could not initialize camera or model');
    }
});

// Load handpose model
async function loadHandposeModel() {
    updateUIWithError('Loading Model', 'Please wait...');
    
    try {
        // Load the MediaPipe Handpose model
        handPoseModel = await handpose.load();
        updateUIWithError('Model Ready', 'Show your hand gestures');
    } catch (error) {
        console.error("Model loading error:", error);
        updateUIWithError('Model Error', 'Could not load hand detection model');
    }
}

// Start continuous detection
function startDetection() {
    if (isProcessing) return;
    
    isProcessing = true;
    detectHands();
}

// Main detection loop
async function detectHands() {
    if (video.paused || video.ended) {
        isProcessing = false;
        return;
    }
    
    const currentTime = Date.now();
    
    // Process frames at controlled intervals to improve performance
    if (currentTime - lastProcessedTime >= processingInterval) {
        try {
            // Get hand predictions from the model
            predictions = await handPoseModel.estimateHands(video);
            
            if (predictions.length > 0) {
                // Format landmarks for our detection function
                const landmarks = predictions[0].landmarks.map(point => [point[0], point[1], point[2]]);
                
                // Process hand landmarks to detect gestures
                const gestureResult = processHandLandmarks(landmarks);
                
                // Add to gesture history for stability
                gestureHistory.push(gestureResult);
                
                // Keep history at fixed length
                if (gestureHistory.length > historyMaxLength) {
                    gestureHistory.shift();
                }
                
                // Use most common gesture from recent history for stability
                const stableGesture = getStableGesture();
                
                // Update UI with detected gesture
                updateDetectionUI(stableGesture);
            } else {
                gestureHistory = [];
                updateUIWithError('No Hand Detected', 'Please ensure your hand is visible');
            }
            
            lastProcessedTime = currentTime;
        } catch (error) {
            console.error("Detection error:", error);
        }
    }
    
    // Continue the detection loop
    requestAnimationFrame(detectHands);
}

// Get the most stable gesture from history
function getStableGesture() {
    if (gestureHistory.length === 0) {
        return {
            gesture: "DETECTING...", 
            meaning: "Analyzing hand movement...",
            confidence: 0.1
        };
    }
    
    // Count occurrences of each gesture
    const gestureCounts = {};
    
    gestureHistory.forEach(item => {
        if (!gestureCounts[item.gesture]) {
            gestureCounts[item.gesture] = {
                count: 0,
                confidence: 0,
                meaning: item.meaning
            };
        }
        gestureCounts[item.gesture].count++;
        gestureCounts[item.gesture].confidence += item.confidence;
    });
    
    // Find the most common gesture
    let maxCount = 0;
    let stableGesture = null;
    
    for (const gesture in gestureCounts) {
        if (gestureCounts[gesture].count > maxCount) {
            maxCount = gestureCounts[gesture].count;
            stableGesture = {
                gesture: gesture,
                meaning: gestureCounts[gesture].meaning,
                confidence: gestureCounts[gesture].confidence / gestureCounts[gesture].count
            };
        }
    }
    
    return stableGesture;
}

// Calculate distance between two points
function distance(point1, point2) {
    return Math.sqrt(
        Math.pow(point1[0] - point2[0], 2) + 
        Math.pow(point1[1] - point2[1], 2)
    );
}

// Process hand landmarks and detect gestures
function processHandLandmarks(landmarks) {
    // Extract specific landmark points for comparison
    const wrist = landmarks[0];
    const thumb_cmc = landmarks[1];
    const thumb_mcp = landmarks[2];
    const thumb_ip = landmarks[3];
    const thumb_tip = landmarks[4];
    
    const index_mcp = landmarks[5];
    const index_pip = landmarks[6];
    const index_dip = landmarks[7];
    const index_tip = landmarks[8];
    
    const middle_mcp = landmarks[9];
    const middle_pip = landmarks[10];
    const middle_dip = landmarks[11];
    const middle_tip = landmarks[12];
    
    const ring_mcp = landmarks[13];
    const ring_pip = landmarks[14];
    const ring_dip = landmarks[15];
    const ring_tip = landmarks[16];
    
    const pinky_mcp = landmarks[17];
    const pinky_pip = landmarks[18];
    const pinky_dip = landmarks[19];
    const pinky_tip = landmarks[20];
    
    // Helper function to check if a finger is extended (tip is higher than mcp)
    const isFingerExtended = (tip, mcp, threshold = 20) => tip[1] < mcp[1] - threshold;
    
    // Helper function to check if fingers are close to each other
    const areFingersClose = (tip1, tip2, threshold = 30) => distance(tip1, tip2) < threshold;

    // 1. Open Palm / "Hello": All fingers extended
    if (isFingerExtended(index_tip, index_mcp) && 
        isFingerExtended(middle_tip, middle_mcp) && 
        isFingerExtended(ring_tip, ring_mcp) && 
        isFingerExtended(pinky_tip, pinky_mcp) &&
        thumb_tip[0] < index_mcp[0]) {  // Thumb out to side
        return {
            gesture: "Open Palm", 
            meaning: "Hello! How are you?",
            confidence: 0.9
        };
    }
    
    // 2. Pointing / "Look": Only index finger extended
    else if (isFingerExtended(index_tip, index_mcp) && 
             !isFingerExtended(middle_tip, middle_mcp, 10) && 
             !isFingerExtended(ring_tip, ring_mcp, 10) && 
             !isFingerExtended(pinky_tip, pinky_mcp, 10)) {
        return {
            gesture: "Pointing", 
            meaning: "Look there! What is that?",
            confidence: 0.85
        };
    }
    
    // 3. Thumbs Up / "Yes": Thumb extended upward, others closed
    else if (thumb_tip[1] < thumb_ip[1] - 30 &&
             !isFingerExtended(index_tip, index_mcp, 10) &&
             !isFingerExtended(middle_tip, middle_mcp, 10) &&
             !isFingerExtended(ring_tip, ring_mcp, 10) &&
             !isFingerExtended(pinky_tip, pinky_mcp, 10)) {
        return {
            gesture: "Thumbs Up", 
            meaning: "Yes! Good! Okay.",
            confidence: 0.9
        };
    }
    
    // 4. Thumbs Down / "No": Thumb extended downward, others closed
    else if (thumb_tip[1] > thumb_ip[1] + 30 &&
             !isFingerExtended(index_tip, index_mcp, 10) &&
             !isFingerExtended(middle_tip, middle_mcp, 10) &&
             !isFingerExtended(ring_tip, ring_mcp, 10) &&
             !isFingerExtended(pinky_tip, pinky_mcp, 10)) {
        return {
            gesture: "Thumbs Down", 
            meaning: "No! Not Good.",
            confidence: 0.9
        };
    }
    
    // 5. Victory / Peace: Index and middle fingers extended, others closed
    else if (isFingerExtended(index_tip, index_mcp) && 
             isFingerExtended(middle_tip, middle_mcp) && 
             !isFingerExtended(ring_tip, ring_mcp, 10) && 
             !isFingerExtended(pinky_tip, pinky_mcp, 10)) {
        return {
            gesture: "Victory (Peace)", 
            meaning: "Victory! Everything is fine.",
            confidence: 0.88
        };
    }
    
    // 6. "Thank You": Flat hand touching the chin then moving forward
    else if (isFingerExtended(index_tip, index_mcp) && 
             isFingerExtended(middle_tip, middle_mcp) && 
             isFingerExtended(ring_tip, ring_mcp) && 
             isFingerExtended(pinky_tip, pinky_mcp) &&
             Math.abs(index_tip[1] - middle_tip[1]) < 15 &&  // Fingers aligned
             Math.abs(middle_tip[1] - ring_tip[1]) < 15 &&
             Math.abs(ring_tip[1] - pinky_tip[1]) < 15) {
        return {
            gesture: "Thank You", 
            meaning: "Thank you very much!",
            confidence: 0.85
        };
    }
    
    // 7. "I Love You": Thumb, index, and pinky extended (ASL sign)
    else if (thumb_tip[0] < thumb_mcp[0] &&  // Thumb extended outward
             isFingerExtended(index_tip, index_mcp) && 
             !isFingerExtended(middle_tip, middle_mcp, 10) && 
             !isFingerExtended(ring_tip, ring_mcp, 10) && 
             isFingerExtended(pinky_tip, pinky_mcp)) {
        return {
            gesture: "I Love You", 
            meaning: "I love you (ASL sign)",
            confidence: 0.92
        };
    }
    
    // 8. "Water": W shape with three middle fingers
    else if (isFingerExtended(index_tip, index_mcp) && 
             isFingerExtended(middle_tip, middle_mcp) && 
             isFingerExtended(ring_tip, ring_mcp) && 
             !isFingerExtended(pinky_tip, pinky_mcp, 10) &&
             !areFingersClose(index_tip, middle_tip) &&
             !areFingersClose(middle_tip, ring_tip)) {
        return {
            gesture: "Water", 
            meaning: "Water or drink, please",
            confidence: 0.82
        };
    }
    
    // 9. "Help": Closed fist with thumb up resting on open palm
    else if (!isFingerExtended(index_tip, index_mcp, 10) &&
             !isFingerExtended(middle_tip, middle_mcp, 10) &&
             !isFingerExtended(ring_tip, ring_mcp, 10) &&
             !isFingerExtended(pinky_tip, pinky_mcp, 10) &&
             thumb_tip[1] < wrist[1]) {
        return {
            gesture: "Help", 
            meaning: "I need help, please",
            confidence: 0.8
        };
    }
    
    // 10. "Food/Eat": Fingers and thumb brought together toward mouth
    else if (areFingersClose(index_tip, thumb_tip) &&
             areFingersClose(middle_tip, thumb_tip) &&
             areFingersClose(ring_tip, thumb_tip) &&
             areFingersClose(pinky_tip, thumb_tip)) {
        return {
            gesture: "Food", 
            meaning: "I'm hungry / I want to eat",
            confidence: 0.85
        };
    }
    
    // 11. "Stop": Hand up, palm facing forward
    else if (isFingerExtended(index_tip, index_mcp) && 
             isFingerExtended(middle_tip, middle_mcp) && 
             isFingerExtended(ring_tip, ring_mcp) && 
             isFingerExtended(pinky_tip, pinky_mcp) &&
             thumb_tip[0] > index_mcp[0]) {  // Thumb across palm
        return {
            gesture: "Stop", 
            meaning: "Stop / Wait",
            confidence: 0.88
        };
    }
    
    // Default state if no specific gesture is detected
    return {
        gesture: "DETECTING...", 
        meaning: "Analyzing hand movement...",
        confidence: 0.1
    };
}

// Update UI with detection results
function updateDetectionUI(result) {
    const gestureLabel = document.getElementById('gestureLabel');
    const sentenceLabel = document.getElementById('sentenceLabel');

    // Update gesture and meaning with smooth transition
    if (gestureLabel.textContent !== result.gesture) {
        gestureLabel.style.opacity = 0;
        setTimeout(() => {
            gestureLabel.textContent = result.gesture;
            gestureLabel.style.opacity = 1;
        }, 200);
    }
    
    if (sentenceLabel.textContent !== result.meaning) {
        sentenceLabel.style.opacity = 0;
        setTimeout(() => {
            sentenceLabel.textContent = result.meaning;
            sentenceLabel.style.opacity = 1;
        }, 200);
    }

    // Update confidence visualization
    updateConfidenceIndicator(result.confidence);
}

// Visualize confidence
function updateConfidenceIndicator(confidence) {
    let confidenceBar = document.getElementById('confidenceBar');
    
    if (!confidenceBar) {
        confidenceBar = document.createElement('div');
        confidenceBar.id = 'confidenceBar';
        confidenceBar.style.position = 'absolute';
        confidenceBar.style.bottom = '0';
        confidenceBar.style.left = '0';
        confidenceBar.style.height = '10px';
        confidenceBar.style.borderRadius = '0 5px 5px 0';
        confidenceBar.style.transition = 'width 0.3s ease, background-color 0.3s ease';
        document.querySelector('.video-container').appendChild(confidenceBar);
    }
    
    confidenceBar.style.width = `${confidence * 100}%`;
    confidenceBar.style.backgroundColor = confidence > 0.8 ? '#22c55e' : 
                                          confidence > 0.5 ? '#f59e0b' : '#ef4444';
}

// Generic error update function
function updateUIWithError(gesture, meaning) {
    document.getElementById('gestureLabel').textContent = gesture;
    document.getElementById('sentenceLabel').textContent = meaning;
}

// Add a visual gesture guide
function addGestureGuide() {
    const container = document.querySelector('.container');
    const guideSection = document.createElement('div');
    guideSection.className = 'gesture-guide';
    guideSection.innerHTML = `
        <h2 style="text-align: center; margin: 30px 0 20px; color: var(--primary-color);">Available Hand Signs</h2>
        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 20px; margin-bottom: 30px;">
            <div class="result-card">
                <div class="result-label">Open Palm</div>
                <div class="result-value">Hello! How are you?</div>
            </div>
            <div class="result-card">
                <div class="result-label">Pointing</div>
                <div class="result-value">Look there!</div>
            </div>
            <div class="result-card">
                <div class="result-label">Thumbs Up</div>
                <div class="result-value">Yes! Good!</div>
            </div>
            <div class="result-card">
                <div class="result-label">Thumbs Down</div>
                <div class="result-value">No! Not Good!</div>
            </div>
            <div class="result-card">
                <div class="result-label">Victory (Peace)</div>
                <div class="result-value">Victory! Peace!</div>
            </div>
            <div class="result-card">
                <div class="result-label">Thank You</div>
                <div class="result-value">Thank you!</div>
            </div>
            <div class="result-card">
                <div class="result-label">I Love You</div>
                <div class="result-value">I love you! (ASL)</div>
            </div>
            <div class="result-card">
                <div class="result-label">Water</div>
                <div class="result-value">Water, please!</div>
            </div>
            <div class="result-card">
                <div class="result-label">Help</div>
                <div class="result-value">I need help!</div>
            </div>
            <div class="result-card">
                <div class="result-label">Food</div>
                <div class="result-value">I'm hungry!</div>
            </div>
            <div class="result-card">
                <div class="result-label">Stop</div>
                <div class="result-value">Stop! Wait!</div>
            </div>
        </div>
    `;
    
    // Insert after the video-section
    const videoSection = document.querySelector('.video-section');
    videoSection.parentNode.insertBefore(guideSection, videoSection.nextSibling);
}

// Call this after DOM content is loaded
document.addEventListener('DOMContentLoaded', () => {
    // Add gesture guide after setup
    setTimeout(addGestureGuide, 1000);
});
    </script>
</body>
</html>
